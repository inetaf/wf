// enum_conditions enumerates all the match conditions that WFP offers
// in its various layers, along with the Go data type that WFP is
// expecting to work with.
//
// This tool is used to figure out the set of matcher structs that
// need to be built, based on the actual filtering options offered by
// WFP. It must be run on a Windows system, and thus isn't part of the
// basic `go generate` run. To update the conditions list, build and
// run this tool by hand.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"reflect"
	"runtime"
	"sort"
	"strings"

	"inet.af/wf"
)

func fatalf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}

func main() {
	outfile := flag.String("out", "zcondition_types.go", "output file to write")
	flag.Parse()

	if runtime.GOOS != "windows" {
		fmt.Fprintf(os.Stderr, "gen_condition_types not regenerating, not running on Windows\n")
		os.Exit(0)
	}

	session, err := wf.New(nil)
	if err != nil {
		fatalf("creating WFP session: %v", err)
	}
	defer session.Close()

	layers, err := session.Layers()
	if err != nil {
		fatalf("listing WFP layers: %v", err)
	}

	fields := map[wf.Field]bool{}
	for _, l := range layers {
		for _, f := range l.Fields {
			fields[*f] = true
		}
	}

	var sorted []wf.Field
	for f := range fields {
		sorted = append(sorted, f)
	}
	sort.Slice(sorted, func(i, j int) bool {
		return wf.GUIDName(sorted[i].Key) < wf.GUIDName(sorted[j].Key)
	})

	var out bytes.Buffer

	out.WriteString(`// Generated by gen_condition_types.go, DO NOT EDIT

package wf

import (
  "reflect"

  "golang.org/x/sys/windows"
  "inet.af/netaddr"
)

var fieldTypes = map[Field]bool{
`)
	for _, field := range sorted {
		fmt.Fprintf(&out, "// %s\n", wf.GUIDName(field.Key))
		fmt.Fprintf(&out, "Field{Key: %#v, Type: ", field.Key)
		typ := strings.TrimPrefix(field.Type.String(), "wf.")
		switch field.Type.Kind() {
		case reflect.Slice, reflect.Struct, reflect.Array:
			fmt.Fprintf(&out, "reflect.TypeOf(%s{})", typ)
		case reflect.String:
			out.WriteString(`reflect.TypeOf("")`)
		default:
			fmt.Fprintf(&out, "reflect.TypeOf(%s(0))", typ)
		}
		out.WriteString("}: true,\n")
	}
	out.WriteString("}\n")

	bs, err := format.Source(out.Bytes())
	if err != nil {
		fatalf("formatting source: %v", err)
	}

	if err := ioutil.WriteFile(*outfile, bs, 0644); err != nil {
		fatalf("writing file: %v", err)
	}
}
